var documenterSearchIndex = {"docs":
[{"location":"home/#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"home/","page":"Home","title":"Home","text":"Welcome to this ","category":"page"},{"location":"home/#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"home/","page":"Home","title":"Home","text":"Here's the full list of contents of this website. ","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"The Cauchy-Schwarz Inequality","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"left( sum_k=1^n a_k b_k right)^2 leq left( sum_k=1^n a_k^2 right) left( sum_k=1^n b_k^2 right)","category":"page"},{"location":"home/","page":"Home","title":"Home","text":"Next, some further useful functionalities. ","category":"page"},{"location":"experiments/markdown/exp_1/","page":"Plot and Histogram","title":"Plot and Histogram","text":"EditURL = \"../exp_1.jl\"","category":"page"},{"location":"experiments/markdown/exp_1/#exp","page":"Plot and Histogram","title":"Plot and Histogram","text":"","category":"section"},{"location":"experiments/markdown/exp_1/","page":"Plot and Histogram","title":"Plot and Histogram","text":"The following page has been generated entirely within a single Julia file (/docs/src/experiments/exp_1.jl), see its source code to see how easy it was done.","category":"page"},{"location":"experiments/markdown/exp_1/","page":"Plot and Histogram","title":"Plot and Histogram","text":"As a show case, here's some random plots using in this case Plots.jl. Dont forget to add any necessary packages to the enviroment and to import them!","category":"page"},{"location":"experiments/markdown/exp_1/#A-familiar-normal-histogram","page":"Plot and Histogram","title":"A familiar normal histogram","text":"","category":"section"},{"location":"experiments/markdown/exp_1/","page":"Plot and Histogram","title":"Plot and Histogram","text":"using Pkg\nPkg.instantiate() # fixes an error where GitHub forgets to instantiate the enviroment.\n\nusing Plots, LaTeXStrings\n\nhistogram(randn(100000,1),legend=false,xlabel=L\"X\",ylabel=\"counts\")","category":"page"},{"location":"experiments/markdown/exp_1/","page":"Plot and Histogram","title":"Plot and Histogram","text":"From now onwards, no need to import anything again, it was imported above (remember this runs in the same Julia file).","category":"page"},{"location":"experiments/markdown/exp_1/#A-friendly-Wiener-process-plot","page":"Plot and Histogram","title":"A friendly Wiener process plot","text":"","category":"section"},{"location":"experiments/markdown/exp_1/","page":"Plot and Histogram","title":"Plot and Histogram","text":"A Wiener Process W_t (also called standard Brownian motion) is a stochastic process with the following properties:","category":"page"},{"location":"experiments/markdown/exp_1/","page":"Plot and Histogram","title":"Plot and Histogram","text":"The process starts at zero: W_0 = 0: .\nIndependent increments: The change W_t - W_s for t  s is independent of past values.\nStationary increments: W_t - W_s sim mathcalN(0 t-s), meaning the increments are normally distributed with mean 0 and variance t - s.\nContinuous paths: The function W_t is continuous with probability 1.\nNo drift: The expected value is mathbbEW_t = 0.\nVariance grows linearly: textVar(W_t) = t.","category":"page"},{"location":"experiments/markdown/exp_1/","page":"Plot and Histogram","title":"Plot and Histogram","text":"Mathematical Definition:","category":"page"},{"location":"experiments/markdown/exp_1/","page":"Plot and Histogram","title":"Plot and Histogram","text":"dW_t sim mathcalN(0 dt)","category":"page"},{"location":"experiments/markdown/exp_1/","page":"Plot and Histogram","title":"Plot and Histogram","text":"where dW_t represents a small random movement over an infinitesimal time step dt.","category":"page"},{"location":"experiments/markdown/exp_1/","page":"Plot and Histogram","title":"Plot and Histogram","text":"The Wiener process is fundamental in stochastic calculus and financial modeling, forming the basis for Geometric Brownian Motion (GBM) used in stock price modeling.","category":"page"},{"location":"experiments/markdown/exp_1/","page":"Plot and Histogram","title":"Plot and Histogram","text":"function Wiener_process(T, N, σ, W_0; N_processes=1)\n    dt = T / N  # Time step size\n    t = range(0, T, length=N+1)  # Time points\n    dW = sqrt(dt) .* randn(N, N_processes)  # Wiener increments for all processes\n    W = σ .* cumsum([zeros(1, N_processes); dW], dims=1)  # Compute Wiener process paths\n    return t, W\nend\n\nplot(Wiener_process(10, 1000, 1, 0, N_processes=10),ylabel=L\"W\",xlabel=L\"t\",legend=false)","category":"page"},{"location":"experiments/markdown/exp_2/","page":"Animations","title":"Animations","text":"EditURL = \"../exp_2.jl\"","category":"page"},{"location":"experiments/markdown/exp_2/#exp","page":"Animations","title":"Animations","text":"","category":"section"},{"location":"experiments/markdown/exp_2/","page":"Animations","title":"Animations","text":"Animations are a great way of conveying science which extend well beyond the capabilities of standard static papers.","category":"page"},{"location":"experiments/markdown/exp_2/","page":"Animations","title":"Animations","text":"# ### A super simple animation\n\nusing Pkg\nPkg.instantiate()\n\nusing Plots, LaTeXStrings\n\ny, x = randn(5000), randn(5000)\n@gif for n=1:50:5000\n    scatter(x[1:n],y[1:n],ylim=(-3,3),xlim=(-3,3),legend=false,alpha=0.1,ms=5,ylabel=L\"y\",xlabel=L\"x\",marker=:o,color=:orange)\nend","category":"page"},{"location":"experiments/markdown/exp_2/#An-interesting-animation","page":"Animations","title":"An interesting animation","text":"","category":"section"},{"location":"experiments/markdown/exp_2/","page":"Animations","title":"Animations","text":"Function to generate Wiener process paths:","category":"page"},{"location":"experiments/markdown/exp_2/","page":"Animations","title":"Animations","text":"function geometric_brownian_motion(T, N, μ, σ, S_0; N_processes=1)\n    dt = T / N  # Time step size\n    t = range(0, T, length=N+1)  # Time points\n    dW = sqrt(dt) .* randn(N, N_processes)  # Wiener increments\n    W = cumsum([zeros(1, N_processes); dW], dims=1)  # Wiener process paths\n    S = S_0 .* exp.((μ - 0.5 * σ^2) .* t .+ σ .* W)\n    return t, S\nend","category":"page"},{"location":"experiments/markdown/exp_2/","page":"Animations","title":"Animations","text":"Generate GBM data:","category":"page"},{"location":"experiments/markdown/exp_2/","page":"Animations","title":"Animations","text":"T, N, μ, σ, S_0, N_processes = 10, 100, 0.15, 0.2, 100, 10\nt, S = geometric_brownian_motion(T, N, μ, σ, S_0, N_processes = N_processes)","category":"page"},{"location":"experiments/markdown/exp_2/","page":"Animations","title":"Animations","text":"Create animation:","category":"page"},{"location":"experiments/markdown/exp_2/","page":"Animations","title":"Animations","text":"@gif for i in 1:N+1\n    plot(t[1:i], S[1:i, :], xlabel=L\"t\", ylabel=L\"S(t)\", title=\"Geometric Brownian Motion Simulation\", legend=false, lw=2, grid=true, xlims=(0, T), ylims=(minimum(S), maximum(S)))\nend","category":"page"},{"location":"experiments/markdown/exp_3/","page":"Mock numerical study","title":"Mock numerical study","text":"EditURL = \"../exp_3.jl\"","category":"page"},{"location":"experiments/markdown/exp_3/#exp","page":"Mock numerical study","title":"Mock numerical study","text":"","category":"section"},{"location":"experiments/markdown/exp_3/#Dynamics-of-M-at-different-magnetic-flux-\\phi","page":"Mock numerical study","title":"Dynamics of M at different magnetic flux phi","text":"","category":"section"},{"location":"experiments/markdown/exp_3/","page":"Mock numerical study","title":"Mock numerical study","text":"In this numerical experiment, we study the dynamics of M as the magnetic flux phi is varied at fixed temperature T and","category":"page"},{"location":"experiments/markdown/exp_3/","page":"Mock numerical study","title":"Mock numerical study","text":"using Pkg\nPkg.instantiate()\n\nusing Plots\n\nscatter(exp.(1:10))\nplot!(exp.(1:10))","category":"page"},{"location":"experiments/markdown/exp_3/#A-relaxing-sine-and-cosine","page":"Mock numerical study","title":"A relaxing sine and cosine","text":"","category":"section"},{"location":"experiments/markdown/exp_3/","page":"Mock numerical study","title":"Mock numerical study","text":"This are awesone sinusoidal functions Here are the functions in LaTeX:","category":"page"},{"location":"experiments/markdown/exp_3/","page":"Mock numerical study","title":"Mock numerical study","text":"cos(x) quad sin(x)","category":"page"},{"location":"experiments/markdown/exp_3/","page":"Mock numerical study","title":"Mock numerical study","text":"This is lovely.","category":"page"},{"location":"experiments/markdown/exp_3/","page":"Mock numerical study","title":"Mock numerical study","text":"plot(sin.(-3:0.01:3))\nplot!(cos.(-3:0.01:3))","category":"page"},{"location":"reference/#Documentation-Index","page":"Reference","title":"Documentation Index","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Here's an index of the available functions.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/#Documentation","page":"Reference","title":"Documentation","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"CurrentModule = Quantum_Geometric_Complexity","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [Quantum_Geometric_Complexity]","category":"page"},{"location":"reference/#Quantum_Geometric_Complexity.Clock-Tuple{Any}","page":"Reference","title":"Quantum_Geometric_Complexity.Clock","text":"Clock(N)\n\nFINISH!! \n\nReturn the Clock matrix...\n\nPerformance comment\n\nIt is much more efficient if returned in Diagonal object: ```julia-repl julia> @btime Clock(1000)^2 # Diagonal object v  11.125 μs (3 allocations: 39.75 KiB) 1000×1000 Diagonal{ComplexF64, Vector{ComplexF64}}:     (output ommitted)\n\njulia> @btime Clock_diagm(1000)^2 # Matrix object 37.858 ms (6 allocations: 30.54 MiB) 1000×1000 Matrix{ComplexF64}:     (output ommitted) ````\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantum_Geometric_Complexity.IPR-Tuple{Any}","page":"Reference","title":"Quantum_Geometric_Complexity.IPR","text":"IPR(v)\n\nFunction for calculating the inverse participation ratio.\n\nMathematically, given some vector v in some basis, this is defined as \n\nIPR(v) ≐ \\sum_n || v_n ||^4.\n\nExamples\n\njulia> IPR( [1/√(4), 1/√(4), 1/√(4), 1/√(4)]  )\n0.25\n\njulia> IPR( [1, 0, 0, 0]  )\n1\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantum_Geometric_Complexity.M-Tuple{Any, Any}","page":"Reference","title":"Quantum_Geometric_Complexity.M","text":"M(ρ, O_basis)\n\nFunction for calculating the macroscopicity M of a density matrix in Hilbert space H×H.\n\nMathematically, given some matrix ρ in H×H, this is defined as \n\nM ≐ -log2( IPR_C[ρ] / γ^2 ).\n\nThis is non trivial so please refer to the paper.\n\nExamples\n\njulia> M(I(2^3)/(2^3), O_basis_spin_half(3))\n-0.0\n\njulia> M(rand_ρ_pure(3), O_basis_spin_half(3))\n4.062587703134164\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantum_Geometric_Complexity.O_basis_bosons-Tuple{Any}","page":"Reference","title":"Quantum_Geometric_Complexity.O_basis_bosons","text":"Performance comment\n\nSome benchmarks:\n\njulia> @btime O_basis_bosons(20)\n885.291 μs (1286 allocations: 11.59 MiB)\n20×20×400 Array{ComplexF64, 3}:\n\njulia> @btime O_basis_bosons(100)\n1.105 s (51410 allocations: 6.78 GiB)\n\nso we seem to be limited by memory unsurprisingly again.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantum_Geometric_Complexity.mul_by_2-Tuple{Any}","page":"Reference","title":"Quantum_Geometric_Complexity.mul_by_2","text":"mul_by_2(x)\n\nMultiplies x by 2.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantum_Geometric_Complexity.mul_by_4-Tuple{Any}","page":"Reference","title":"Quantum_Geometric_Complexity.mul_by_4","text":"mul_by_4(x)\n\nMultiplies x by 4.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantum_Geometric_Complexity.purity-Tuple{Vector}","page":"Reference","title":"Quantum_Geometric_Complexity.purity","text":"purity(ρ_μ::Vector)\n\nFunction for calculating the purity of a vector in characteristic space C.\n\nMathematically, given some vector ρ in characteristic space C, this is defined as \n\nγ ≐ \\sum_μ  ρ_μ ρ_μ^* ≡ ||ρ||^2\n\nExamples\n\njulia> ρ_vec_temp = ρ_vec(rand_ρ_pure(3), O_basis_spin_half(3))\n64-element Vector{ComplexF64}:\n0.35355339059327373 + 0.0im\n-0.19777757955054376 - 4.336808689942018e-19im\n-0.07369283640174634 + 5.204170427930421e-18im\n0.030330980132771558 + 0.0im\n0.052689065818701745 + 1.0408340855860843e-17im\n                    ⋮\n-0.01752572646095066 + 0.0im\n-0.23462520253833954 + 0.0im\n0.1193174939662679 - 4.336808689942018e-19im\n0.10279530237835932 - 8.673617379884035e-18im\n-0.10936868240286046 + 0.0im\n\njulia> purity(ρ_vec_temp)\n0.9999999999999999 + 0.0im\n\npurity\n\njulia> ρ_vec_temp = ρ_vec(I(2^3)/2^3, O_basis_spin_half(3))\n64-element Vector{ComplexF64}:\n0.35355339059327373 + 0.0im\n                0.0 + 0.0im\n                0.0 + 0.0im\n                0.0 + 0.0im\n                0.0 + 0.0im\n                    ⋮\n                0.0 + 0.0im\n                0.0 + 0.0im\n                0.0 + 0.0im\n                0.0 + 0.0im\n                0.0 + 0.0im\n\njulia> purity(ρ_vec_temp)\n0.12499999999999997\n\njulia> 1/(2^3)\n0.125\n\njulia> ρ_vec_temp = ρ_vec(rand_ρ_pure(3), O_basis_spin_half(3))\n64-element Vector{ComplexF64}:\n0.35355339059327373 + 0.0im\n-0.14065223381828953 + 5.204170427930421e-18im\n0.10474649723834337 + 6.071532165918825e-18im\n0.05213855626731899 + 0.0im\n-0.23021903371920083 + 1.3010426069826053e-18im\n                    ⋮\n-0.007396885500585001 + 0.0im\n-0.14963824202038384 + 0.0im\n0.0038745649216279177 + 1.734723475976807e-18im\n0.025673666375129044 + 6.071532165918825e-18im\n0.022366636393981332 + 0.0im\n\njulia> purity(ρ_vec_temp)\n1.0\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantum_Geometric_Complexity.ρ_mat-Tuple{Any, Any}","page":"Reference","title":"Quantum_Geometric_Complexity.ρ_mat","text":"ρmat(ρ, Obasis)\n\nInverse of ρ_mat, that is, converts vector in characteristic space C to its Hilbert space representation in H×H. That is, mathematically, it's a function \n\nρ_vec : C,O → H×H\n\nPerformance comment\n\nThis function also suffered from performance issues like ρ_vec(ρ, O_basis) which were also solved with Einsum. For more details see ρ_vec(ρ, O_basis) documentation.\n\nExamples\n\njulia> O_basis = O_basis_spin_half(1)\n2×2×4 Array{ComplexF64, 3}:\n[:, :, 1] =\n    0.707107+0.0im       0.0+0.0im\n        0.0+0.0im  0.707107+0.0im\n\n[:, :, 2] =\n        0.0+0.0im  0.707107+0.0im\n    0.707107+0.0im       0.0+0.0im\n\n[:, :, 3] =\n    0.0+0.0im       0.0+0.707107im\n    0.0-0.707107im  0.0+0.0im\n\n[:, :, 4] =\n    0.707107+0.0im        0.0+0.0im\n        0.0+0.0im  -0.707107+0.0im\n\njulia> ψ = [1, 1]/√(2)\n2-element Vector{Float64}:\n    0.7071067811865475\n    0.7071067811865475\n\njulia> ρ_μ = ρ_vec(ψ*ψ', O_basis)\n4-element Vector{ComplexF64}:\n    0.7071067811865474 + 0.0im\n    0.7071067811865474 + 0.0im\n                0.0 + 0.0im\n                0.0 + 0.0im\n\njulia> ρ_mat(ρ_μ, O_basis)\n2×2 Matrix{ComplexF64}:\n    0.5+0.0im  0.5+0.0im\n    0.5+0.0im  0.5+0.0im\n\njulia> ψ*ψ'\n2×2 Matrix{Float64}:\n    0.5  0.5\n    0.5  0.5\n\n\n\n\n\n","category":"method"},{"location":"reference/#Quantum_Geometric_Complexity.ρ_vec-Tuple{Any, Any}","page":"Reference","title":"Quantum_Geometric_Complexity.ρ_vec","text":"ρvec(ρ, Obasis)\n\nConverts density matrix ρ ∈ H×H to its vector representation in characteristic space C spanned by O. That is, mathematically, it's a function \n\nρ_vec : H×H,O → C\n\nPerformance comment\n\nThis function used to be written as \n\nfunction ρ_vec(ρ, O_basis)\n    N = size(O_basis)[3]\n    ρ_temp = ComplexF64.(zeros(N))\n    for n=1:N\n        ρ_temp[n] = tr(ρ*O_basis[:,:,n])\n    end\n    return ρ_temp\nend\n\nbut it had performance issues:\n\njulia> ρ = rand_ρ(7) # output ommited\njulia> O_basis = O_basis_spin_half(7) # output ommited\njulia> @btime ρ_vec(ρ,O_basis)\n3.413 s (65540 allocations: 8.00 GiB)\n(further output ommited)\njulia> @btime ρ_vec_einsum(ρ,O_basis)\n346.840 ms (2 allocations: 256.05 KiB)\n(further output ommited)\n\nso current default implementation is with Einsum.\n\nExamples\n\njulia> O_basis = O_basis_spin_half(1)\n2×2×4 Array{ComplexF64, 3}:\n[:, :, 1] =\n0.707107+0.0im       0.0+0.0im\n    0.0+0.0im  0.707107+0.0im\n\n[:, :, 2] =\n    0.0+0.0im  0.707107+0.0im\n0.707107+0.0im       0.0+0.0im\n\n[:, :, 3] =\n0.0+0.0im       0.0+0.707107im\n0.0-0.707107im  0.0+0.0im\n\n[:, :, 4] =\n0.707107+0.0im        0.0+0.0im\n    0.0+0.0im  -0.707107+0.0im\n\njulia> ψ = [1, 1]/√(2)\n2-element Vector{Float64}:\n0.7071067811865475\n0.7071067811865475\n\njulia> ρ_vec(ψ*ψ', O_basis)\n4-element Vector{ComplexF64}:\n0.7071067811865474 + 0.0im\n0.7071067811865474 + 0.0im\n                0.0 + 0.0im\n                0.0 + 0.0im\n\n\n\n\n\n","category":"method"},{"location":"citing/#Citing-this-work","page":"Citing this work","title":"Citing this work","text":"","category":"section"},{"location":"citing/","page":"Citing this work","title":"Citing this work","text":"Here's how you can cite this amazing work!","category":"page"}]
}
